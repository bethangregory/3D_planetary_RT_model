// things to improve/change in code


--profile+optimize GPU code (texture memory likely to be last possible big improvement)
  --replacing atmospheric variables (density, cross section, source function) with texture units on device may help
    --these objects would pre-fecth in a volume around the current index, 
    --would need to rewrite device-side voxel_vector interface, adding a texture object
    --texture objects need to know about the grid structure, which is currently not known to emission objects.
    --this would replace linear interpolation with hardware interpolation
    --need fast coordinate point finders? (right now this is done brute force)
--remove transmission object; this is superseded by lineshape_tracker
--fix transmission so that it is specified inside emission;
--fast exp calculation http://gallium.inria.fr/blog/fast-vectorizable-math-approx/
--32 bit vs 64 bit differences in code output?
--comparison with anderson
--comparison with chaufray
--problems with asym_calc
--any analytic test case? Maybe something asymptotic from Holstein?
--alternate source function calculation guaranteed to populate all elements of matrix?

UIUC collaboration:
--think more about normalization effects on degeneracy

Near term:
--python fitting routine (get it running fast)
--move finite-difference derivative calculation inside observation_fit
--deuterium and hot H physical densities
--O I 102.6 nm radiance calculation (may require frequency redistribution)
--include single-scattering anisotropy

Needed next 6 months:
--IPH background (for IUVS apoapse images)

Small code improvements
  --improve treatment of planetary shadow by doubling up voxels on the shadow boundary, with one treating the inside of the shadow and the other the outside.

  --use monotone cubic interpolation in brightness calculation: 
    --implement this: http://articles.adsabs.harvard.edu/pdf/1990A%26A...239..443S
    -- or switch to GSL: https://www.gnu.org/software/gsl/doc/html/interp.html#d-higher-level-interface

  --move emission tracker inside of emission, specific to emissions (allowing different rules for each line)
    --not clear how to do this: a catchall call with a switch for each mode is possible, but this could have a significant performance overhead.
    --pointers are problematic because of CUDA; host/device pointer handling is tricky.


longer-term:
--more realistic exosphere (Vidal-Madjar or similar)
--frequency redistribution (needs some refactoring of emission object)
--RT anisotropy??
--new scheme for ray distribution: https://www.sciencedirect.com/science/article/pii/S0097849312000568
  --computing solid angle associated with each ray may be difficult with this scheme
--Efficient Voigt line functions: https://yorkspace.library.yorku.ca/xmlui/bitstream/handle/10315/10172/The%20Voigt%20and%20complex%20error%20functions.pdf;jsessionid=E049E45AB37B74D487ADC7DEAB691A2F?sequence=1
--Fast Multipole method for Source Function calculation?
  --A short course on fast multipole methods: https://math.nyu.edu/faculty/greengar/shortcourse_fmm.pdf
  --A kernel-independent adaptive fast multipole algorithm in two and three dimensions: https://web.stanford.edu/~lexing/fmm.pdf
--Some other potential solution methods to employ:
  --A fast algorithm for radiative transport in isotropic media: https://arxiv.org/pdf/1610.00835.pdf
  --Fast algorithms for integral formulations of steady-state radiative transfer equation: https://arxiv.org/pdf/1802.03061.pdf
  --Fast direct solvers for integral equations in complex three-dimensional domains: https://amath.colorado.edu/faculty/martinss/2014_CBMS/Biblio/2009_acta.pdf
  --A FAST DIRECT SOLVER FOR STRUCTURED LINEAR SYSTEMS BY RECURSIVE SKELETONIZATION: https://arxiv.org/pdf/1110.3105.pdf
  --Solving Inverse Problems with Deep Learning: https://drive.google.com/file/d/1uVZ_obbchNWGV50qNTZXwbAymDuLLaWF/view
  --RESONANCE LINE TRANSFER CALCULATIONS BY DOUBLING THIN LAYERS: http://articles.adsabs.harvard.edu/pdf/1989ApJ...346..481Y
  
  
done:
xx--compute voxel densities as average over zone rather than typical value
xx--switch from tabulated holstein T to computing it just-in-time as line integrals are traversed
    (smells like frequency redistribution;
     should be relatively easy, add line profile to tau_tracker)
xx--add uniform ray method
xx--OBSOLETE due to line profile calculation
    incoroporate CO2 absorption in holstein function instead of midpoint approximation 
    (needs 2d holstein interps with absorption)
xx--compare with pratik brightness values (they match!)
xx--fix CUDA implementation, brightness + matrix
xx--lots of optimization (30 Oct 2020) >10x speedup.
xx  --reduced memory usage of lineshape_tracker dramatically
    --switch to shared memory for brightness calc
    --use-fast-math works now
    --converted literals to float (3x speedup!)
    --reduced line samples and wavelength range from 12/5 to 6/4 in lineshape_tracker
    --separate influence and brightness lineshape_tracker calculation
